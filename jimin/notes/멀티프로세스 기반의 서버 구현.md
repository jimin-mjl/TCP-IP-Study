# 멀티프로세스의 이해

### 다중 접속 서버의 구현 방법

- 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식으로 서비스 제공
    - 윈도우에서는 지원하지 않는다.
- 멀티플렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방법으로 서비스 제공
- 멀티쓰레딩 기반 서버 : 클라이언트 수만큼 쓰레드를 생성하는 방식으로 서비스 제공

### 프로세스란

프로그램이 실행을 위해 메인 메모리에 올라간 시점부터 프로세스가 된다. 

프로세스는 운영체제의 관점에서 프로그램 흐름의 기본 단위이다.

프로세스는 서로 독립된 메모리 영역을 가진다. 

### 프로세스의 생성

부모 프로세스는 `fork()` 함수의 호출을 통해 자식 프로세스를 생성할 수 있다. 

`fork()` 함수는 실행 중이던 프로세스의 복사본을 생성한다. 즉, 자식 프로세스는 부모 프로세스와 완전히 동일한 내용의 메모리 영역을 가지게 된다. 

`fork()` 함수 호출 이후의 흐름은 함수의 반환값을 통해 구분한다. `fork()` 함수는 각각의 경우에 반환하는 값이 다르다.

- 부모 프로세스 : 생성된 자식 프로세스의 pid
- 자식 프로세스 : 0

<br />

# 좀비 프로세스

### 좀비 프로세스란

프로세스가 할 일을 마치고 종료되면 메모리에서 내려가 사라져야 하는데, 사라지지 않고 리소스를 계속 잡아먹고 있는 프로세스는 **좀비 프로세스**라고 한다.

### 좀비 프로세스의 생성 이유

`fork()` 함수에 의해 생성된 프로세스는 다음의 경우에 종료된다.

- 인자를 전달하면서 `exit()` 을 호출하는 경우
- main 함수에서 return문을 실행하면서 값을 반환하는 경우

이렇게 반환되는 값은 OS에게 전달된다. 

그런데 반환값을 전달받은 OS는 부모 프로세스에게 이를 전달할 때까지 자식 프로세스를 소멸시키지 않는다. 이때 소멸되지 못한 자식 프로세스는 부모 프로세스가 종료되어 같이 종료될 때까지 살아있게 된다. 바로 이런 상황에 놓여있는 프로세스를 좀비 프로세스라고 한다. 

OS는 부모 프로세스가 자식 프로세스의 반환값을 요청하지 않는 이상, 부모 프로세스에게 전달하지 않는다. 즉, 좀비 프로세스가 생기는 것을 막기 위해서는 **부모 프로세스가 자식 프로세스의 반환값을 요청**하도록 해야 한다. 

### 좀비 프로세스의 소멸 방법

1. `wait()` 함수 사용하기
    
    `wait()` 함수는 자식 프로세스가 종료되면서 반환한 값을 매개변수로 받은 주소에 저장한다. 만약 호출 시점에 종료된 프로세스가 없으면 임의의 자식 프로세스가 종료될 때까지 부모 프로세스를 **블로킹** 상태로 만든다. 
    
    반환값에는 자식 프로세스의 반환값 외에도 다른 정보들이 포함되어 있으므로, 다음 매크로 함수들을 통해 값을 분리한 다음 값을 가져오도록 한다.
    
    - WIFEXITED : 자식 프로세스가 정상 종료한 경우 true를 반환한다.
    - WEXITSTATUS : 자식 프로세스의 반환값을 반환한다.
    
    ```cpp
    int status;
    
    wait(&status);
    if (WIFEXITED)
    	cout << "자식 프로세스로부터 전달받은 수: " << WEXITSTATUS(status) << endl;
    ```
    
2. `waitpid()` 함수 사용하기 
    
    `waitpid()` 함수는 자식 프로세스의 pid를 첫 번째 매개변수로 전달해서 해당 프로세스가 종료되었는지 확인한다. -1을 전달하면 `wait()` 함수처럼 임의의 프로세스가 종료되기를 기다린다.   
    
    마지막 인자로 매크로 상수 WNOHANG을 전달하면 종료된 프로세스가 없어도 블로킹되지 않고 빠져나온다.
    
<br />

# 시그널 핸들링

### signal() 함수

**시그널**이란 특정 상황이 발생했음을 알리기 위해 OS가 프로세스에게 전달하는 메세지를 의미한다. 시그널 핸들링이란, 이 메세지를 처리하는 작업을 의미한다. 

프로세스는 자식 프로세스가 종료되었을 때, OS에게 특정 함수를 호출해달라고 요구할 수 있다. 시그널을 등록하는 것이다. 이는 `signal()` 함수를 통해 이루어진다. 

`signal()` 함수는 시그널 옵션과 핸들러 함수 포인터를 받는다. 대표적인 시그널 옵션은 다음과 같다.

- SIGALRM : `alarm()` 함수를 통해 등록했던 시간이 다 된 경우
- SIGINT : `ctrl + c` 가 입력된 경우
- SIGCHLD : 자식 프로세스가 종료된 경우

이 때, 마지막 옵션인 SIGCHLD를 활용하면 자식 프로세스가 종료되었을 때에 대한 시그널 핸들링이 가능하고, 이를 통해 좀비 프로세스의 생성을 막을 수 있다. 

### sigaction() 함수

위에서 설명한 `signal()` 함수는 유닉스 계열의 OS 별로 동작의 차이를 보일 수 있는 반면, `sigaction()` 함수는 차이를 보이지 않는다. 그래서 요즘은 더 안정적으로 동작하는 `sigaction()` 함수를 더 많이 사용한다. 

`signal()` 함수처럼 두 번째 인자로 함수 포인터를 바로 전달하는 게 아니라, 핸들러 함수 포인터를 `sigaction` 이라는 구조체로 감싸서 전달한다는 것을 유의하면 된다. 

<br />

# 멀티프로세스 서버 구현 시의 주의점

`fork()` 함수를 통해 만들어진 자식 프로세스는 서버 소켓과 클라이언트 소켓의 파일 디스크립터를 가지고 있다. 그런데 이때, 하나의 소켓에 복수의 파일 디스크립터가 존재하는 경우, 파일 디스크립터가 모두 종료되지 않으면 소켓은 소멸되지 않는다. 따라서 각각의 프로세스에서 사용할 소켓만 남겨두고 사용하지 않을 소켓은 닫아줘야 한다. 일반적으로 부모 프로세스는 서버 소켓을 관리하고 자식 프로세스에게 클라이언트 소켓의 관리를 위임하므로, 부모 프로세스는 클라이언트 소켓을 닫아주고 자식 프로세스는 서버 소켓을 닫아주면 되겠다.
