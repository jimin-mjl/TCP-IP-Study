# Time-wait과 Binding Error(주소 할당 에러)

> 두 호스트 간에 소켓이 연결된 상태에서, 서버가 먼저 연결을 끊고 바로 다시 연결을 시도하면 `bind() error` 라는 메세지가 출력되면서 서버가 실행되지 않는다. 그 이유는 무엇일까?

### Time-wait

![time-wait](/jimin/notes/images/time-wait.png)
[이미지 출처]("https://docs.likejazz.com/time-wait/")

소켓이 종료될 때는 위 이미지처럼 Four-way Handshaking의 과정을 거친다. 그런데 여기서 주목할 부분이 있다. 바로 **먼저 FIN 메세지를 전송한 호스트**의 경우, 응답 메세지를 보내고 바로 종료되지 않고 일정 시간 동안 살아있는 **Time-wait** 과정을 거친다는 것이다.

왜 바로 종료되지 않을까? 보낸 응답 메세지가 중간에 분실될 가능성이 있기 때문이다. 호스트 A는 FIN 메세지를 전송한 후, 호스트 B으로부터의 응답 메세지를 기다린다. 그런데 이 메세지가 중간에 분실되면 어떻게 될까? 시간이 지나도 응답 메세지를 받지 못하자 호스트 A는 다시 한 번 호스트 B에게 FIN 메세지를 보낸다. 그런데 만약 호스트 B가 응답 메세지를 보내고 바로 연결을 종료한 상태라면? FIN 메세지는 호스트 B에게 닿지 못하고 호스트 A는 영원히 호스트 B로부터의 응답 메세지를 받지 못하게 된다. 따라서 이런 상황에 대비하고자, 마지막으로 응답 메세지를 보낸 호스트는 일정 시간 동안 연결을 살려둔 채 대기하게 되는 것이다.

다시 처음의 질문으로 돌아가보자. Time-wait은 연결 종료 과정에서 먼저 FIN 메세지를 보낸 호스트가 거치는 과정이다. 그러므로 서버가 먼저 연결을 끊을 경우, 서버는 소켓 종료 함수가 호출된 후에도 일정 시간 동안 연결을 살려두고 있다. 즉, 서버가 사용했던 포트가 여전히 사용 중인 상태이다. 그래서 연결 종료 후 바로 재실행을 하게 되면, 사용 중인 포트를 사용하려고 시도하는 것이기 때문에 주소 할당 시에 에러가 나게 되는 것이다. 단, 클라이언트의 경우에는 먼저 종료하더라도 문제 없이 곧바로 재실행할 수 있는데, 이는 포트를 정해두고 바인딩하는 서버와는 달리 클라이언트는 `connect()` 함수 호출 시에 매번 임의의 포트가 자동으로 할당이 되기 때문이다.

<br />

### SO_REUSEADDR

서버가 다운된 경우에는 일분일초가 아쉬운 상황인데 time-wait 동안 마냥 기다리고 있을 수만은 없다. 그리고 Time-wait은 네트워크의 상태에 따라 얼마나 지속될지 알 수 없다.

소켓의 옵션 중 `SO_REUSEADDR`을 통해 이런 상황을 방지할 수 있다. 이 옵션은 Time-wait 상태에 있는 소켓의 포트 번호를 새로운 소켓에 할당할 수 있도록 해주는 옵션이다. 디폴트는 False이므로 이를 `setsockopt()` 기능을 통해 True로 변경해주면 된다.

```cpp
bool value = true;
setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, static_cast<char*>(&value), sizeof(value));
```

<br />

# Nagle 알고리즘

### Nagle 알고리즘이란

> Nagle 알고리즘이란, 앞서 전송한 데이터에 대한 응답 메세지를 받아야만 다음 데이터를 전송하도록 하는 알고리즘이다.

Nagle 알고리즘은 다음과 같은 특징을 가진다.

1. 패킷 전송 후 응답 메세지를 받을 때까지 전송을 멈춘다.
2. 멈춰있는 동안 전송할 세그먼트가 버퍼에 쌓인다.

이를 그림으로 표현하면 다음과 같다.
![nagle algorithm](/jimin/notes/images/nagle-algorithm.png)
[이미지 출처](http://www.orentec.co.kr/teachlist/TCP_IP_1/teach_sub1.php)

### Nagle 알고리즘을 왜 사용할까?

Nagle 알고리즘을 적용한 경우와 적용하지 않은 경우를 비교해보자. 적용한 경우는 총 4개의 패킷만을 주고받은 반면, 적용하지 않은 경우는 총 10개의 패킷을 주고 받았다. 그런데 패킷은 한 번 전송될 때마다 포함되어야 하는 헤더 정보가 수십 바이트에 이른다. 따라서 네트워크 트래픽을 고려했을 때, 알고리즘을 적용하는 게 훨씬 효율으로 네트워크를 사용할 수 있다.

### Nagle 알고리즘을 적용하지 않는 게 좋은 경우

Nagle 알고리즘이 항상 좋은 것은 아니다. 패킷 전송 후 상대가 ACK 패킷을 보낼 때까지 기다려야 하기 때문에 그만큼 응답 속도가 느려지기 때문이다. 따라서 전송하는 데이터의 특성에 따라서 Nagle 알고리즘의 적용 여부에 따른 트래픽 차이가 크지 않으면서, 데이터 전송 속도가 중요한 경우는 Nagle 알고리즘을 적용하지 않는 것이 좋다.

예를 들어, **용량이 큰 데이터 파일을 전송**하는 경우가 그런 경우이다. 파일 데이터를 출력 버퍼로 밀어넣는 작업은 시간이 오래 걸리지 않기 때문에 Nagle 알고리즘을 적용하지 않아도 데이터가 패킷을 꽉 채운 상태에서 전송된다. 따라서 Nagle 알고리즘의 적용 여부에 따라 패킷의 수가 크게 차이가 나지 않는다. 이런 경우는 전송 속도 면에서 이득을 볼 수 있도록 Nagle 알고리즘을 끄는 게 더 좋을 것이다.

### 결론

Nagle 알고리즘을 사용하면 트래픽이 적어지는 대신, 속도가 느려진다. 따라서 데이터의 특성을 고려해서 알고리즘의 적용 여부를 판단하자.

### Nagle 알고리즘 끄기

소켓 옵션 중 `TCP_NODELAY` 를 True로 변경해주면 된다. 디폴트는 False이다.

```cpp
bool value = true;
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, static_cast<char*>(&value), sizeof(value));
```

### 참고

- [https://slidesplayer.org/amp/16339516/](https://slidesplayer.org/amp/16339516/)
