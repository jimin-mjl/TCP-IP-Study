# Time-wait과 Binding Error(주소 할당 에러)

> 두 호스트 간에 소켓이 연결된 상태에서, 서버가 먼저 연결을 끊고 바로 다시 연결을 시도하면 `bind() error` 라는 메세지가 출력되면서 서버가 실행되지 않는다. 그 이유는 무엇일까?

### Time-wait

![time-wait](/jimin/notes/images/time-wait.png)
[이미지 출처]("https://docs.likejazz.com/time-wait/")

소켓이 종료될 때는 위 이미지처럼 Four-way Handshaking의 과정을 거친다. 그런데 여기서 주목할 부분이 있다. 바로 **먼저 FIN 메세지를 전송한 호스트**의 경우, 응답 메세지를 보내고 바로 종료되지 않고 일정 시간 동안 살아있는 **Time-wait** 과정을 거친다는 것이다.

왜 바로 종료되지 않을까? 보낸 응답 메세지가 중간에 분실될 가능성이 있기 때문이다. 호스트 A는 FIN 메세지를 전송한 후, 호스트 B으로부터의 응답 메세지를 기다린다. 그런데 이 메세지가 중간에 분실되면 어떻게 될까? 시간이 지나도 응답 메세지를 받지 못하자 호스트 A는 다시 한 번 호스트 B에게 FIN 메세지를 보낸다. 그런데 만약 호스트 B가 응답 메세지를 보내고 바로 연결을 종료한 상태라면? FIN 메세지는 호스트 B에게 닿지 못하고 호스트 A는 영원히 호스트 B로부터의 응답 메세지를 받지 못하게 된다. 따라서 이런 상황에 대비하고자, 마지막으로 응답 메세지를 보낸 호스트는 일정 시간 동안 연결을 살려둔 채 대기하게 되는 것이다.

다시 처음의 질문으로 돌아가보자. Time-wait은 연결 종료 과정에서 먼저 FIN 메세지를 보낸 호스트가 거치는 과정이다. 그러므로 서버가 먼저 연결을 끊을 경우, 서버는 소켓 종료 함수가 호출된 후에도 일정 시간 동안 연결을 살려두고 있다. 즉, 서버가 사용했던 포트가 여전히 사용 중인 상태이다. 그래서 연결 종료 후 바로 재실행을 하게 되면, 사용 중인 포트를 사용하려고 시도하는 것이기 때문에 주소 할당 시에 에러가 나게 되는 것이다. 단, 클라이언트의 경우에는 먼저 종료하더라도 문제 없이 곧바로 재실행할 수 있는데, 이는 포트를 정해두고 바인딩하는 서버와는 달리 클라이언트는 `connect()` 함수 호출 시에 매번 임의의 포트가 자동으로 할당이 되기 때문이다.

<br />

### SO_REUSEADDR

서버가 다운된 경우에는 일분일초가 아쉬운 상황인데 time-wait 동안 마냥 기다리고 있을 수만은 없다. 그리고 Time-wait은 네트워크의 상태에 따라 얼마나 지속될지 알 수 없다.

소켓의 옵션 중 `SO_REUSEADDR`을 통해 이런 상황을 방지할 수 있다. 이 옵션은 Time-wait 상태에 있는 소켓의 포트 번호를 새로운 소켓에 할당할 수 있도록 해주는 옵션이다. 디폴트는 False이므로 이를 `setsockopt()` 기능을 통해 True로 변경해주면 된다.
