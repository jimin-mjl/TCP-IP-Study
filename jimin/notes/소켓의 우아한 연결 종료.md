# TCP 기반의 Half-close
### 우아한 연결 종료란

TCP 소켓을 통해서 두 호스트가 연결되어 상호 간 데이터 전송이 가능한 상태가 되면, 이를 **스트림이 형성된 상태**라고 한다. 그런데 물(stream)이 한 쪽 방향으로만 흐르듯이 입출력 스트림도 일방향에 대해서만 데이터 전송이 가능하다. 따라서 두 호스트가 서로 데이터를 주고 받기 위해서는 두 개의 입출력 스트림이 필요하다. TCP 소켓이 연결되면 두 개의 입출력 스트림이 형성된다. 

소켓의 연결을 종료한다는 것은 스트림의 연결을 끊는 것이다. 그런데 이 두 개의 스트림은 서로 독립적이다. 즉, 하나가 끊어졌다고 해서 다른 하나도 끊어지는 것은 아니다. 따라서 소켓을 종료할 때는 두 개의 스트림을 각각 종료해야 하는데, 이 때의 방식에는 완전 종료와 우아한 종료가 있다. 

**완전 종료**란 두 스트림의 연결을 한 번에 모두 끊어버리는 것이다. 일반적으로 생각하는 종료의 방식이다. 그런데 이 방식의 문제점은 호스트 A가 마지막 데이터를 호스트 B에게 전송을 완료하고 종료한 시점에 호스트 B로부터 전송되는 데이터가 있었다면, 그 데이터는 호스트 A의 입력 스트림에 도착하지 못하고 중간에 소멸해버린다는 것이다. 따라서 더 이상 전송할 게 없어서 출력 스트림을 닫아도 데이터를 수신할 수는 있게 입력 스트림은 열어놓는 방식으로 종료의 단계를 구분할 필요가 있다. **우아한 종료는** 바로 이렇게 한 쪽 스트림만 종료하는 **Half-close** 방식을 의미한다.

### Half-close 가 필요한 이유

위에서 설명한 예시를 조금 더 구체화해보자. 서버가 클라이언트에게 전송할 데이터를 모두 전송했다면, 데이터 전송이 끝났다는 사실을 클라이언트에게 알릴 필요가 있다. 이 때 전송하는 것이 **EOF(End of File)**이다. EOF는 서버가 출력 스트림을 닫으면 클라이언트에게 보내진다. 그리고 EOF를 수신한 클라이언트도 이를 잘 수신했음을 서버에게 알릴 필요가 있다. 그런데 서버가 데이터 전송 후 소켓을 완전 종료한 상태라면 클라이언트로부터의 메세지를 더 이상 수신하지 못한다. 따라서 서버는 출력 스트림만 닫고 입력 스트림은 여전히 열어놓아야 하는 것이다.

### 우아한 연결 종료의 구현

소켓의 완전 종료는 `close() (linux) / closesocket() (windows)` 함수를 통해 구현한다. 반면 우아한 종료는 `shutdown()` 함수로 구현할 수 있다. 인자값으로는 소켓의 핸들값과 옵션을 주고 되는데, 옵션으로는 입력 스트림과 출력 스트림 중 어느 것을 종료할 것인지, 또는 둘 다 종료할 것인지를 알려주면 된다. 

윈도우의 `shutdown()` 함수의 두 번째 인자 옵션은 다음과 같다. 

- SD_RECEIVE  : 입력 스트림 종료
- SD_SEND : 출력 스트림 종료
- SD_BOTH : 둘 다 종료
